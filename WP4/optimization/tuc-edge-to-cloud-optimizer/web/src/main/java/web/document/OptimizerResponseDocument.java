package web.document;

import com.fasterxml.jackson.annotation.JsonRawValue; // Import this!
import com.google.gson.Gson; // Ensure you have Gson available
import com.fasterxml.jackson.annotation.JsonRawValue;
import com.google.gson.annotations.Expose;
import core.exception.OptimizerException;
import core.parser.network.Network;
import core.parser.network.Site;
import core.parser.workflow.Operator;
import core.parser.workflow.OptimizationRequest;
import core.parser.workflow.PlacementPlatform;
import core.parser.workflow.PlacementSite;
import core.structs.Tuple;
import lombok.Data;
import lombok.EqualsAndHashCode;
import optimizer.OptimizationResourcesBundle;
import optimizer.plan.OptimizationPlan;
import optimizer.plan.SimpleOptimizationPlan;
import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.DateFormat;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;
import web.repository.RepositoryDocument;

import java.io.Serializable;
import java.util.*;

/**
 * The output of an optimization process.
 */
@Document(indexName = "crexdata_result", createIndex = true) //Added by Xenia
@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OptimizerResponseDocument implements Serializable, RepositoryDocument<OptimizerResponseDocument> {
    //Ignore user input timestamp, overwrite with autogenerated ID instead.
    @Expose(deserialize = false)
    @EqualsAndHashCode.Include
    @Id
    private String id;

    //Guaranteed to be unique for every *workflow* optimization
    //Guaranteed to be the same across continuous optimization responses
    @Field(name = "optimizationRequestId", type = FieldType.Keyword)
    private String optimizationRequestId;

    //Don't expose to JSON
    @Field(name = "@timestamp", type = FieldType.Date, format = DateFormat.date_optional_time, store = true)
    private Date modifiedAt = new Date();

    @Field(name = "networkName", type = FieldType.Text, store = true)
    private String networkName;

    @Field(name = "dictionaryName", type = FieldType.Text, store = true)
    private String dictionaryName;

    @Field(name = "algorithmUsed", type = FieldType.Text, store = true)
    private String algorithmUsed;

    @Field(name = "workflow", type = FieldType.Nested, store = true)
    private OptimizationRequest workflow;

    @Field(name = "operatorsPretty", type = FieldType.Text, store = true)
    private String operatorsPretty;

    @Field(name = "performance", type = FieldType.Text, store = true)
    private String performance;

    @Field(name = "alternativeWorkflows", type = FieldType.Text, store = true)
    private List<OptimizationRequest> alternativeWorkflows;

    @Field(name = "placementSiteDiffFromRoot", type = FieldType.Flattened, store = true)
    private Map<String, String> placementSiteDiffFromRoot = null;

    @Field(name = "user", type = FieldType.Text, store = true)
    private String user;

    private OptimizerResponseDocument() {
    }

    public OptimizerResponseDocument(OptimizationResourcesBundle optBundle) throws OptimizerException {
        OptimizationPlan bestPlan = optBundle.getPlanQueue().peek();
        if (bestPlan == null) {
            throw new OptimizerException("No suitable plans were found.");
        }
        this.workflow = fillOutput(optBundle.getWorkflow(), bestPlan, optBundle.getNetwork());
        this.operatorsPretty = bestPlan.getOperatorsAndImplementations().toString();
        this.performance = optBundle.getStatisticsBundle().toString();
        this.dictionaryName = optBundle.getNewDictionary().getName();
        this.networkName = optBundle.getNetwork().getNetwork();
        this.optimizationRequestId = optBundle.getRequestId();
        this.algorithmUsed = optBundle.getTraversalAlgorithmName();
        this.user = optBundle.getUser();

        this.placementSiteDiffFromRoot = calculateDiff(optBundle.getRootPlan(), optBundle.getWorkflow());

        //For alternative plans
        this.alternativeWorkflows = new ArrayList<>();
        optBundle.getPlanQueue().poll();
        for (OptimizationPlan altPlan : optBundle.getPlanQueue()) {
            this.alternativeWorkflows.add(fillOutput(optBundle.getWorkflow(), altPlan, optBundle.getNetwork()));
        }
    }

    private Map<String, String> calculateDiff(SimpleOptimizationPlan rootPlan, OptimizationRequest workflow) {
        Map<String, String> res = new HashMap<>();
        for (PlacementSite site : workflow.getPlacementSites()) {
            for (PlacementPlatform platform : site.getAvailablePlatforms()) {
                //for (String wf_operator : platform.getOperators()) {
                for (Operator wf_operator : platform.getOperators()) {
                    for (Map.Entry<String, Tuple<String, String>> entry : rootPlan.getOperatorsAndImplementations().entrySet()) {
//                        if (wf_operator.equals(entry.getKey())) {
                        if (wf_operator.getName().equals(entry.getKey())) {
                            res.put(entry.getKey(), String.format("%s -> %s", entry.getValue().toString(), new Tuple<>(site.getSiteName(), platform.getPlatformName()).toString()));
                            break;
                        }
                    }
                }
            }
        }
        return res;
    }

    private OptimizationRequest fillOutput(OptimizationRequest request, OptimizationPlan optimizerPlan, Network network) {
        request.setPlacementSites(new ArrayList<>());

        if (optimizerPlan == null) {
            return request;
        }

        Map<String, PlacementSite> sites = new HashMap<>();
        for (Site site : network.getSites()) {
            PlacementSite newSite = new PlacementSite(site);
            sites.put(newSite.getSiteName(), newSite);
            request.getPlacementSites().add(newSite);
        }

        PlacementSite defaultSite = new PlacementSite("UnsupportedSite", new ArrayList<>());
        PlacementPlatform defaultPlatform = new PlacementPlatform("UnsupportedPlatform", null, new ArrayList<>());

        LinkedHashMap<String, Tuple<String, String>> implementations = optimizerPlan.getOperatorsAndImplementations();
        for (String operatorName : implementations.keySet()) {
            Tuple<String, String> sitePlatformPair = implementations.get(operatorName);
            String currSite = sitePlatformPair._1;
            String currPlatform = sitePlatformPair._2;

            if (!sites.containsKey(currSite)) {
                request.getPlacementSites().add(defaultSite);
                currSite = defaultSite.getSiteName();
            }

            if (!sites.containsKey(currSite)) {
                sites.get(currSite).getAvailablePlatforms().add(defaultPlatform);
                currPlatform = defaultPlatform.getPlatformName();
            }
            final String this_platform = currPlatform;

            PlacementSite currPlacementSite = sites.get(currSite);
            List<PlacementPlatform> availablePlatforms = currPlacementSite.getAvailablePlatforms();

            System.out.println("Operator: " + operatorName);
            System.out.println("Current site: " + currPlacementSite.getSiteName());
            availablePlatforms.forEach(p -> System.out.println("Available platform: " + p.getPlatformName()));
            System.out.println();

            PlacementPlatform platform = availablePlatforms.stream()
                    .filter(p -> p.getPlatformName().equals(this_platform))
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("Error while placing operators."));

            platform.getOperators().add(new Operator(operatorName));
        }

        return request;
    }

    @Override
    public String id() {
        return this.id;
    }

    @Override
    public OptimizerResponseDocument getObject() {
        return this;
    }

    public String getUser() {
        return user;
    }

    public String getId() {
        return id;
    }
}
