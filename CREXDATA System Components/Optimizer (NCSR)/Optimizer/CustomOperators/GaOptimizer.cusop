<?xml version="1.0" encoding="UTF-8"?><process version="10.5.000">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="10.5.000" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="SYSTEM"/>
    <process expanded="true">
      <operator activated="true" class="python_scripting:python_transformer" compatibility="10.1.002" expanded="true" height="68" name="GA Optimizer" width="90" x="447" y="34">
        <parameter key="editable" value="true"/>
        <parameter key="operator" value="{&#10;  &quot;name&quot;: &quot;Custom Python Transformer&quot;,&#10;  &quot;dropSpecial&quot;: false,&#10;  &quot;parameters&quot;: [&#10;    {&#10;      &quot;name&quot;: &quot;distance_type&quot;,&#10;      &quot;type&quot;: &quot;string&quot;,&#10;      &quot;description&quot;: &quot;By default parameters are of type string\.&quot;,&#10;      &quot;optional&quot;: false,&#10;      &quot;value&quot;: &quot;l1&quot;&#10;    },&#10;    {&#10;      &quot;name&quot;: &quot;pop_num&quot;,&#10;      &quot;type&quot;: &quot;integer&quot;,&#10;      &quot;description&quot;: &quot;Population Number&quot;,&#10;      &quot;optional&quot;: false,&#10;      &quot;value&quot;: 4&#10;    },&#10;    {&#10;      &quot;name&quot;: &quot;termination_crit&quot;,&#10;      &quot;type&quot;: &quot;category&quot;,&#10;      &quot;description&quot;: &quot;Categorical parameter\.&quot;,&#10;      &quot;categories&quot;: [&#10;        &quot;genmax&quot;,&#10;        &quot;fitmin&quot;&#10;      ],&#10;      &quot;optional&quot;: false,&#10;      &quot;value&quot;: &quot;genmax&quot;&#10;    }&#10;  ],&#10;  &quot;inputs&quot;: [&#10;    {&#10;      &quot;name&quot;: &quot;data&quot;,&#10;      &quot;type&quot;: &quot;table&quot;&#10;    }&#10;  ],&#10;  &quot;outputs&quot;: [&#10;    {&#10;      &quot;name&quot;: &quot;out&quot;,&#10;      &quot;type&quot;: &quot;table&quot;&#10;    }&#10;  ]&#10;}.from __future__ import print_function&#10;import threading&#10;import random&#10;import time&#10;import math&#10;import csv&#10;import json&#10;import sys&#10;import pickle&#10;import logging&#10;import os&#10;import requests&#10;import numpy as np&#10;import pandas as pd&#10;from deap import base&#10;from deap import creator&#10;from deap import tools&#10;from deap import algorithms&#10;&#10;def is_number(s):&#10;    try:&#10;        float(s)&#10;        return True&#10;    except ValueError:&#10;        return False&#10;&#10;class ConstantParameter(object):&#10;&#10;    def __init__(self, name, value):&#10;        self\.name = name&#10;        self\.value = value&#10;&#10;    def randomDraw(self):&#10;        return self\.value&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        return self\.value&#10;&#10;    def parse(self, s):&#10;        if is_number(s):&#10;            if &quot;\.&quot; in s or &quot;e&quot; in s:&#10;                return float(s)&#10;            return int(s)&#10;        return s&#10;&#10;class NumericParameter(object):&#10;&#10;    def __init__(self, name, lower, upper, sigma):&#10;        self\.name = name&#10;        self\.lower = lower&#10;        self\.upper = upper&#10;        self\.sigma = sigma&#10;&#10;    def randomDraw(self):&#10;        x = self\.uni_rand_func(self\.lower, self\.upper)&#10;        return x&#10;&#10;&#10;class IntParameter(NumericParameter):&#10;&#10;    def __init__(self, name, lower, upper, sigma):&#10;        super(IntParameter, self)\.__init__(name, lower, upper, sigma)&#10;        self\.uni_rand_func = random\.randint&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        if random\.random() &lt;= indpb:&#10;            x += random\.gauss(mu, self\.sigma)&#10;            x = int(max(self\.lower, min(self\.upper, round(x))))&#10;        return x&#10;&#10;    def parse(self, s):&#10;        return int(s)&#10;&#10;class FloatParameter(NumericParameter):&#10;&#10;    def __init__(self, name, lower, upper, sigma):&#10;        super(FloatParameter, self)\.__init__(name, lower, upper, sigma)&#10;        self\.uni_rand_func = random\.uniform&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        if random\.random() &lt;= indpb:&#10;            x += random\.gauss(mu, self\.sigma)&#10;            x = max(self\.lower, min(self\.upper, x))&#10;        return x&#10;&#10;    def parse(self, s):&#10;        return float(s)&#10;&#10;    def get_points(self, n_points):&#10;        step = (self\.upper - self\.lower)/n_points&#10;        return [float('%\.4g' % x) for x in np\.arange(self\.lower, self\.upper, step)]&#10;&#10;#import logging&#10;#logging\.basicConfig()&#10;#log = logging\.getLogger(&quot;a&quot;)&#10;&#10;def str_to_bool(s):&#10;    if s\.lower() == &quot;true&quot;:&#10;        return True&#10;    else:&#10;        return False&#10;&#10;class ListParameter(object):&#10;&#10;    def __init__(self, name, categories, element_type):&#10;        self\.name = name&#10;        self\.categories = categories&#10;&#10;        if element_type == 'float':&#10;            self\.parse_func = float&#10;        elif element_type == 'int':&#10;            self\.parse_func = int&#10;        elif element_type == 'string':&#10;            self\.parse_func = str&#10;        elif element_type == 'logical':&#10;            self\.parse_func = str_to_bool&#10;        else:&#10;            raise ValueError(&quot;Invalid type: {} - must be one of 'float', 'int', 'string', or 'logical'&quot;)&#10;&#10;    def parse(self, s):&#10;        return self\.parse_func(s)&#10;&#10;class CategoricalParameter(ListParameter):&#10;&#10;    def __init__(self, name, categories, element_type):&#10;        super(CategoricalParameter, self)\.__init__(name, categories, element_type)&#10;&#10;    def randomDraw(self):&#10;        i = random\.randint(0, len(self\.categories) - 1)&#10;        return self\.categories[i]&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        global log&#10;        if random\.random() &lt;= indpb:&#10;            a = self\.randomDraw()&#10;            while x == a:&#10;                a = self\.randomDraw()&#10;            x = a&#10;        return x&#10;&#10;class OrderedParameter(ListParameter):&#10;&#10;    def __init__(self, name, categories, sigma, element_type):&#10;        super(OrderedParameter, self)\.__init__(name, categories, element_type)&#10;        self\.sigma = sigma&#10;&#10;    def randomDraw(self):&#10;        i = random\.randint(0, len(self\.categories) - 1)&#10;        return self\.categories[i]&#10;&#10;    def drawIndex(self, i):&#10;        n = random\.randint(1, self\.sigma)&#10;        n = i + (n if random\.random() &lt; 0\.5 else -n)&#10;        n = max(0, min(len(self\.categories) - 1, n))&#10;        return n&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        if random\.random() &lt;= indpb:&#10;            i = self\.categories\.index(x)&#10;            n = self\.drawIndex(i)&#10;            while n == i:&#10;                n = self\.drawIndex(i)&#10;&#10;            x = self\.categories[n]&#10;        return x&#10;&#10;class LogicalParameter:&#10;&#10;    def __init__(self, name):&#10;        self\.name = name&#10;&#10;    def randomDraw(self):&#10;        return random\.random() &lt; 0\.5&#10;&#10;    def mutate(self, x, mu, indpb):&#10;        if random\.random() &lt;= indpb:&#10;            x = not x&#10;        return x&#10;&#10;    def parse(self, s):&#10;        if s\.lower() == &quot;true&quot;:&#10;            return True&#10;        else:&#10;            return False&#10;&#10;def create_parameters(data, ignore_sigma=False):&#10;    # with open(param_file) as json_file:&#10;    #     data = json\.load(json_file)&#10;&#10;    params = []&#10;    for item in data:&#10;        name = item['name']&#10;        print(&quot;{}&quot;\.format(name))&#10;        t = item['type']&#10;        if ignore_sigma:&#10;            sigma = float('nan')&#10;        if t == 'int' or t == 'float':&#10;            lower = item['lower']&#10;            upper = item['upper']&#10;            if not ignore_sigma:&#10;                sigma = item['sigma']&#10;&#10;            if t == 'int':&#10;                params\.append(IntParameter(name, int(lower), int(upper),&#10;                                       int(sigma)))&#10;            else:&#10;                params\.append(FloatParameter(name, float(lower), float(upper),&#10;                                       float(sigma)))&#10;&#10;        elif t == 'categorical':&#10;            vs = item['values']&#10;            element_type = item['element_type']&#10;            params\.append(CategoricalParameter(name, vs, element_type))&#10;&#10;        elif t == 'logical':&#10;            params\.append(LogicalParameter(name))&#10;&#10;        elif t == &quot;ordered&quot;:&#10;            vs = item['values']&#10;            if not ignore_sigma:&#10;                sigma = item['sigma']&#10;            element_type = item['element_type']&#10;            params\.append(OrderedParameter(name, vs, sigma, element_type))&#10;        elif t == 'constant':&#10;            vs = item['value']&#10;            params\.append(ConstantParameter(name, vs))&#10;&#10;    return params&#10;&#10;# Global variables&#10;experiment_folder = os\.path\.join('\./', 'exp_folder')&#10;os\.makedirs(experiment_folder, exist_ok=True)&#10;logging\.basicConfig(&#10;    format='%(message)s',&#10;    filename=os\.path\.join(experiment_folder, &quot;generations\.log&quot;),&#10;    level=logging\.INFO&#10;)&#10;logging\.info(&quot;Logging started successfully\.&quot;)&#10;transformer = None&#10;&#10;&#10;class Transformer:&#10;&#10;    def __init__(self, ga_params, clf=None, scaler=None):&#10;        self\.ga_params = ga_params&#10;&#10;    def mutate(self, population, indpb):&#10;        &quot;&quot;&quot;&#10;        Mutates the values in list individual with probability indpb&#10;        &quot;&quot;&quot;&#10;        for i, param in enumerate(self\.ga_params):&#10;            individual = param\.mutate(population[i], mu=0, indpb=indpb)&#10;            population[i] = individual&#10;&#10;        return population,&#10;&#10;    def cxUniform(self, ind1, ind2, indpb):&#10;        for _ in range(100):&#10;            c1, c2 = tools\.cxUniform(ind1, ind2, indpb)&#10;&#10;        return (c1, c2)&#10;&#10;    def random_params(self):&#10;        draws = []&#10;        for p in self\.ga_params:&#10;            draws\.append(round(p\.randomDraw(), 2))&#10;&#10;        return draws&#10;&#10;    def parse_init_params(self, params_file):&#10;        init_params = []&#10;        with open(params_file) as f_in:&#10;            reader = csv\.reader(f_in)&#10;            header = next(reader)&#10;            for row in reader:&#10;                init_params\.append(dict(zip(header, row)))&#10;        return init_params&#10;&#10;&#10;def printf(val):&#10;    print(val)&#10;    sys\.stdout\.flush()&#10;&#10;&#10;def obj_func(x):&#10;    &quot;&quot;&quot;Placeholder objective function&quot;&quot;&quot;&#10;    return 0&#10;&#10;&#10;def num(s):&#10;    &quot;&quot;&quot;Convert string to int or float&quot;&quot;&quot;&#10;    try:&#10;        return int(s)&#10;    except ValueError:&#10;        return float(s)&#10;&#10;&#10;def create_list_of_json_strings(list_of_lists, super_delim=&quot;;&quot;):&#10;    &quot;&quot;&quot;Create string of ; separated jsonified maps&quot;&quot;&quot;&#10;    res = []&#10;    global transformer&#10;    for l in list_of_lists:&#10;        jmap = {}&#10;        for i, p in enumerate(transformer\.ga_params):&#10;            jmap[p\.name] = l[i]&#10;&#10;        jstring = json\.dumps(jmap)&#10;        res\.append(jstring)&#10;&#10;    return (super_delim\.join(res))&#10;&#10;&#10;def queue_map(obj_func, pops):&#10;    &quot;&quot;&quot;&#10;    Send population to server and receive fitness scores from HTTP response&#10;    &quot;&quot;&quot;&#10;    global proc_id&#10;    &#10;    if not pops:&#10;        return [(999\.0,) for _ in pops]&#10;&#10;    url = &quot;https://server\.crexdata\.eu/webapi/DEFAULT/api/v1/services/barrieroptimization/create-barrier-height-simulations/?example=example&quot;&#10;&#10;    payload = {&#10;        &quot;data&quot;: [&#10;            {&#10;                &quot;optimizerRequestID&quot;: proc_id,&#10;                &quot;parameters&quot;: json\.dumps(pops)&#10;            }&#10;        ]&#10;    }&#10;    headers = {'Content-type': 'application/json'}&#10;&#10;    print(f&quot;Submitting {len(pops)} individuals\.\.\.&quot;)&#10;    &#10;    try:&#10;        r = requests\.post(url, json=payload, headers=headers, timeout=900)&#10;        &#10;        print(f&quot;Status Code: {r\.status_code}&quot;)&#10;        print(f&quot;Response Body: {r\.text}&quot;)&#10;        &#10;        if r\.status_code == 200:&#10;            response_data = r\.json()&#10;            &#10;            # Extract from HTTP response&#10;            if 'data' in response_data and len(response_data['data']) &gt; 0:&#10;                data_item = response_data['data'][0]&#10;                &#10;                # Verify optimizer ID&#10;                if data_item\.get('optimizerRequestID') == proc_id:&#10;                    result = data_item\.get(&quot;results&quot;)&#10;                    &#10;                    if result:&#10;                        # Parse if string: &quot;[0\.214, 0\.214, \.\.\.]&quot;&#10;                        if isinstance(result, str):&#10;                            result = json\.loads(result)&#10;                        &#10;                        print(f&quot;✓ Received {len(result)} fitness scores from HTTP: {result}&quot;)&#10;                        &#10;                        # CRITICAL: Convert to list of tuples for DEAP&#10;                        fitness_tuples = [(float(score),) for score in result]&#10;                        &#10;                        print(f&quot;✓ Converted to DEAP format: {fitness_tuples}&quot;)&#10;                        return fitness_tuples&#10;                    else:&#10;                        print(&quot;⚠ No results field in response&quot;)&#10;                else:&#10;                    print(f&quot;⚠ Optimizer ID mismatch: expected {proc_id}, got {data_item\.get('optimizerRequestID')}&quot;)&#10;            else:&#10;                print(&quot;⚠ Invalid response structure&quot;)&#10;        else:&#10;            print(f&quot;⚠ HTTP error: {r\.status_code}&quot;)&#10;        &#10;        # If we get here, something went wrong&#10;        print(&quot;✗ Failed to get fitness scores, returning penalty values&quot;)&#10;        return [(999\.0,) for _ in pops]&#10;        &#10;    except Exception as e:&#10;        print(f&quot;✗ Error: {e}&quot;)&#10;        import traceback&#10;        traceback\.print_exc()&#10;        return [(999\.0,) for _ in pops]&#10;&#10;&#10;def make_random_parameters():&#10;    &quot;&quot;&quot;Performs initial random draw on each parameter&quot;&quot;&quot;&#10;    return transformer\.random_params()&#10;&#10;&#10;def custom_mutate(individual, indpb):&#10;    &quot;&quot;&quot;Mutates the values in list individual with probability indpb&quot;&quot;&quot;&#10;    return transformer\.mutate(individual, indpb)&#10;&#10;&#10;def cxUniform(ind1, ind2, indpb):&#10;    return transformer\.cxUniform(ind1, ind2, indpb)&#10;&#10;&#10;def timestamp(scores):&#10;    return str(time\.time())&#10;&#10;&#10;def eaSimpleExtended(population, toolbox, cxpb, mutpb, term, ngen, stats=None,&#10;                     halloffame=None, verbose=__debug__, checkpoint=None):&#10;    &quot;&quot;&quot;Extended evolutionary algorithm with checkpointing&quot;&quot;&quot;&#10;    visited_inds = {}&#10;    &#10;    if checkpoint:&#10;        with open(checkpoint, &quot;rb&quot;) as cp_file:&#10;            cp = pickle\.load(cp_file)&#10;        population = cp[&quot;population&quot;]&#10;        halloffame = cp[&quot;halloffame&quot;]&#10;        logbook = cp[&quot;logbook&quot;]&#10;        random\.setstate(cp[&quot;rndstate&quot;])&#10;    else:&#10;        logbook = tools\.Logbook()&#10;        logbook\.header = ['gen', 'nevals'] + (stats\.fields if stats else [])&#10;&#10;    # Evaluate the individuals with an invalid fitness&#10;    invalid_ind = [ind for ind in population &#10;                   if (not ind\.fitness\.valid) and (str(ind) not in visited_inds)]&#10;    fitnesses = toolbox\.map(toolbox\.evaluate, invalid_ind)&#10;    &#10;    for ind, fit in zip(invalid_ind, fitnesses):&#10;        ind\.fitness\.values = fit&#10;        visited_inds[str(ind)] = fit&#10;&#10;    if halloffame is not None:&#10;        halloffame\.update(population)&#10;    &#10;    record = stats\.compile(population) if stats else {}&#10;    logbook\.record(gen=0, nevals=len(invalid_ind), **record)&#10;    &#10;    if verbose:&#10;        for p in population:&#10;            logging\.debug(&quot;0, {}, {}, {}&quot;\.format(0, p, p\.fitness))&#10;    &#10;    logging\.info(&quot;Initial Generation fitness variance = {}&quot;\.format(&#10;        math\.pow(float(logbook\.select(&quot;std&quot;)[-1]), 2)))&#10;    logging\.debug(&quot;Term crit type: {}&quot;\.format(type(ngen)))&#10;    &#10;    if term == 'genmax':  # Run for ngens&#10;        logging\.debug(&quot;Following normal termination criterion process\.&quot;)&#10;        &#10;        for gen in range(1, ngen + 1):&#10;            offspring = toolbox\.select(population, len(population))&#10;            offspring = algorithms\.varAnd(offspring, toolbox, cxpb, mutpb)&#10;            &#10;            for ind in offspring:&#10;                if str(ind) in visited_inds:&#10;                    ind\.fitness\.values = visited_inds[str(ind)]&#10;            &#10;            invalid_ind = [ind for ind in offspring &#10;                          if (not ind\.fitness\.valid) and (str(ind) not in visited_inds)]&#10;            fitnesses = toolbox\.map(toolbox\.evaluate, invalid_ind)&#10;            &#10;            for ind, fit in zip(invalid_ind, fitnesses):&#10;                ind\.fitness\.values = fit&#10;                visited_inds[str(ind)] = fit&#10;&#10;            if halloffame is not None:&#10;                halloffame\.update(offspring)&#10;&#10;            population[:] = offspring&#10;&#10;            record = stats\.compile(population) if stats else {}&#10;            logbook\.record(gen=gen, nevals=len(invalid_ind), **record)&#10;            &#10;            cp = dict(population=population, generation=gen, halloffame=halloffame,&#10;                     logbook=logbook, rndstate=random\.getstate())&#10;            &#10;            with open(checkpoint_file, &quot;wb&quot;) as cp_file:&#10;                pickle\.dump(cp, cp_file)&#10;            &#10;            logging\.info(&quot;Generation {} Stored at {}&quot;\.format(&#10;                gen, time\.strftime(&quot;%H:%M:%S&quot;, time\.localtime())))&#10;            &#10;            if verbose:&#10;                printf(&quot;Logbookstream: {}\\nhalloffame: {}\\n&quot;\.format(&#10;                    logbook\.stream, halloffame))&#10;                for p in population:&#10;                    logging\.debug(&quot;0, {}, {}, {}&quot;\.format(gen, p, p\.fitness))&#10;                for h in halloffame:&#10;                    logging\.debug(&quot;-1, {}, {}, {}&quot;\.format(gen, h, h\.fitness))&#10;    &#10;    else:  # Run while population fitness variance is less than limit&#10;        counter = 0&#10;        gen = 1&#10;        &#10;        while counter &lt; termination_args:&#10;            logging\.debug(&quot;Into while, counter = {}&quot;\.format(counter))&#10;            &#10;            offspring = toolbox\.select(population, len(population))&#10;            offspring = algorithms\.varAnd(offspring, toolbox, cxpb, mutpb)&#10;            &#10;            for ind in offspring:&#10;                if str(ind) in visited_inds:&#10;                    ind\.fitness\.values = visited_inds[str(ind)]&#10;            &#10;            invalid_ind = [ind for ind in offspring &#10;                          if (not ind\.fitness\.valid) and (str(ind) not in visited_inds)]&#10;            fitnesses = toolbox\.map(toolbox\.evaluate, invalid_ind)&#10;            &#10;            for ind, fit in zip(invalid_ind, fitnesses):&#10;                ind\.fitness\.values = fit&#10;                visited_inds[str(ind)] = fit&#10;            &#10;            if halloffame is not None:&#10;                halloffame\.update(offspring)&#10;&#10;            population[:] = offspring&#10;&#10;            record = stats\.compile(population) if stats else {}&#10;            logbook\.record(gen=gen, nevals=len(invalid_ind), **record)&#10;            &#10;            cp = dict(population=population, generation=gen, halloffame=halloffame,&#10;                     logbook=logbook, rndstate=random\.getstate())&#10;            &#10;            with open(checkpoint_file, &quot;wb&quot;) as cp_file:&#10;                pickle\.dump(cp, cp_file)&#10;            &#10;            logging\.info(&quot;Generation {} Stored at {}&quot;\.format(&#10;                gen, time\.strftime(&quot;%H:%M:%S&quot;, time\.localtime())))&#10;            &#10;            if verbose:&#10;                printf(&quot;Logbookstream: {}\\nhalloffame: {}\\n&quot;\.format(&#10;                    logbook\.stream, halloffame))&#10;                for p in population:&#10;                    logging\.debug(&quot;0, {}, {}, {}&quot;\.format(gen, p, p\.fitness))&#10;                for h in halloffame:&#10;                    logging\.debug(&quot;-1, {}, {}, {}&quot;\.format(gen, h, h\.fitness))&#10;            &#10;            if term == &quot;fitmin&quot;:&#10;                if float(logbook\.select(&quot;min&quot;)[-1]) &lt;= ngen:&#10;                    counter += 1&#10;                else:&#10;                    counter = 0&#10;            elif term == &quot;fitvar&quot;:&#10;                if math\.pow(float(logbook\.select(&quot;std&quot;)[-1]), 2) &lt;= ngen:&#10;                    counter += 1&#10;                else:&#10;                    counter = 0&#10;            elif term == &quot;fitavg&quot;:&#10;                if float(logbook\.select(&quot;avg&quot;)[-1]) &lt;= ngen:&#10;                    counter += 1&#10;                else:&#10;                    counter = 0&#10;            else:&#10;                logging\.info(&quot;Unknown GA configuration value: '{}'\.\.\. Exiting&quot;\.format(term))&#10;                counter = termination_args&#10;&#10;            logging\.debug(&quot;Generation fitness variance = {}, counter is now: {}&quot;\.format(&#10;                math\.pow(float(logbook\.select(&quot;std&quot;)[-1]), 2), counter))&#10;            gen += 1&#10;&#10;    logging\.info(&quot;{}\\n&quot;\.format(logbook\.stream))&#10;    return population, logbook&#10;&#10;&#10;def run_optimizer():&#10;    &quot;&quot;&quot;Main GA execution function&quot;&quot;&quot;&#10;    global ga_config, ga_params, termination_crit, termination_args&#10;    global crossover_prob, mutation_prob, tournament_size, pop_num&#10;    global checkpoint_file, transformer&#10;    &#10;    seed = 1234567&#10;&#10;    distance_type_id = ga_config['distance_type']&#10;    logging\.info(&quot;Crossover probability: {}, Mutation probability: {}, Tournament size: {}&quot;\.format(&#10;        crossover_prob, mutation_prob, tournament_size))&#10;    logging\.info(&quot;No\. of population: {}, Random seed: {}, GA parameters: {}&quot;\.format(&#10;        pop_num, seed, ga_params))&#10;    logging\.info(&quot;Distance type - [{}]\\t Termination criterion - [{}] - args [{}]\\n&quot;\.format(&#10;        distance_type_id, termination_crit, termination_args))&#10;    logging\.info(&quot;Begin at: {}&quot;\.format(time\.strftime(&quot;%H:%M:%S&quot;, time\.localtime())))&#10;    &#10;    random\.seed(seed)&#10;    ga_parameters = create_parameters(ga_params)&#10;    transformer = Transformer(ga_parameters)&#10;&#10;    # DEAP class creators&#10;    creator\.create(&quot;FitnessMin&quot;, base\.Fitness, weights=(-1\.0,))&#10;    creator\.create(&quot;Individual&quot;, list, fitness=creator\.FitnessMin)&#10;&#10;    # DEAP method definitions&#10;    toolbox = base\.Toolbox()&#10;    toolbox\.register(&quot;individual&quot;, tools\.initIterate, creator\.Individual,&#10;                     make_random_parameters)&#10;    toolbox\.register(&quot;population&quot;, tools\.initRepeat, list, toolbox\.individual)&#10;    toolbox\.register(&quot;evaluate&quot;, obj_func)&#10;    toolbox\.register(&quot;mate&quot;, cxUniform, indpb=crossover_prob)&#10;    toolbox\.register(&quot;mutate&quot;, custom_mutate, indpb=mutation_prob)&#10;    toolbox\.register(&quot;select&quot;, tools\.selTournament, tournsize=tournament_size)&#10;    toolbox\.register(&quot;map&quot;, queue_map)&#10;&#10;    pop = toolbox\.population(n=pop_num)&#10;&#10;    print(&quot;\\n\\n\\n {} \\n\\n\\n\\n&quot;\.format(pop))&#10;&#10;    hof = tools\.HallOfFame(pop_num)&#10;    stats = tools\.Statistics(lambda ind: ind\.fitness\.values)&#10;    stats\.register(&quot;avg&quot;, np\.mean)&#10;    stats\.register(&quot;std&quot;, np\.std)&#10;    stats\.register(&quot;min&quot;, np\.min)&#10;    stats\.register(&quot;max&quot;, np\.max)&#10;    stats\.register(&quot;ts&quot;, timestamp)&#10;&#10;    pop, log = eaSimpleExtended(pop, toolbox, cxpb=crossover_prob, mutpb=mutation_prob,&#10;                               term=termination_crit, ngen=num(termination_args),&#10;                               stats=stats, halloffame=hof, verbose=True, checkpoint=None)&#10;&#10;    fitnesses = [str(p\.fitness\.values[0]) for p in pop]&#10;    logging\.info(&quot;Logbook: \\n{}&quot;\.format(log))&#10;    logging\.info(&quot;\\n Hall of Fame: \\n&quot;)&#10;    logging\.info(&quot;End at: {}&quot;\.format(time\.strftime(&quot;%H:%M:%S&quot;, time\.localtime())))&#10;    &#10;    for h in hof:&#10;        logging\.debug(&quot;-1, {}, {}, {}&quot;\.format(-1, h, h\.fitness))&#10;    &#10;    # Return results as DataFrame&#10;    result_df = pd\.DataFrame([{&#10;        'proc_ID': proc_id,&#10;        'barrier_heights': list(hof[0]),&#10;        'fitness_score': hof[0]\.fitness\.values[0]&#10;    }])&#10;    return result_df&#10;&#10;&#10;def rm_main(data, parameters):&#10;    &quot;&quot;&quot;Main entry point - processes input data and runs GA optimizer&quot;&quot;&quot;&#10;    global ga_config, ga_params&#10;    global termination_crit, termination_args, crossover_prob, mutation_prob&#10;    global tournament_size, pop_num, checkpoint_file, proc_id&#10;&#10;    print('Processing optimization request\.\.\.')&#10;    &#10;    # Get the incoming data from the last row&#10;    incoming_data_str = data\.iloc[-1]['value']&#10;    print(f&quot;Incoming data type: {type(incoming_data_str)}&quot;)&#10;    &#10;    # Parse the JSON string&#10;    incoming_data = json\.loads(incoming_data_str)&#10;    &#10;    # Extract required values&#10;    optimizer_request_id = incoming_data['optimizerRequestID']&#10;    fitness_score = incoming_data['fitnessScore']&#10;    barriers = incoming_data['barriers']&#10;    &#10;    # Build ga_chromosome_def dynamically from barriers&#10;    ga_chromosome_def = []&#10;    for barrier in barriers:&#10;        chromosome = {&#10;            &quot;name&quot;: barrier['name'],&#10;            &quot;type&quot;: &quot;float&quot;,&#10;            &quot;lower&quot;: barrier['minHeight'],&#10;            &quot;upper&quot;: barrier['maxHeight'],&#10;            &quot;sigma&quot;: 0\.1&#10;        }&#10;        ga_chromosome_def\.append(chromosome)&#10;    &#10;    # Build the ga_config&#10;    ga_config_dict = {&#10;        &quot;process_id&quot;: optimizer_request_id,&#10;        &quot;experiment_folder&quot;: &quot;optimizer_runs&quot;,&#10;        &quot;timepoint&quot;: &quot;now&quot;,&#10;        &quot;ga_config\.json&quot;: {&#10;            &quot;distance_type&quot;: parameters[&quot;distance_type&quot;],&#10;            &quot;termination_crit&quot;: parameters[&quot;termination_crit&quot;],&#10;            &quot;termination_args&quot;: fitness_score,&#10;            &quot;pop_num&quot;: parameters[&quot;pop_num&quot;],&#10;            &quot;crossover_prob&quot;: 0\.75,&#10;            &quot;mutation_prob&quot;: 0\.5,&#10;            &quot;tournament_size&quot;: 3,&#10;            &quot;ga_chromosome_def&quot;: ga_chromosome_def&#10;        }&#10;    }&#10;    &#10;    # Print for verification&#10;    print(&quot;Generated ga_config:&quot;)&#10;    print(json\.dumps(ga_config_dict, indent=2))&#10;    print(f&quot;\\nNumber of barriers processed: {len(barriers)}&quot;)&#10;    for i, barrier in enumerate(barriers, 1):&#10;        print(f&quot;Barrier {i}: {barrier['name']} (height range: {barrier['minHeight']}-{barrier['maxHeight']})&quot;)&#10;    &#10;    # Set global variables from the generated config&#10;    proc_id = ga_config_dict\.get('process_id', 'default_proc_id')&#10;    ga_config = ga_config_dict[&quot;ga_config\.json&quot;]&#10;    &#10;    print(&quot;Loaded configuration: {}&quot;\.format(ga_config))&#10;    &#10;    # Assign values to global parameters&#10;    termination_crit = ga_config['termination_crit']&#10;    termination_args = ga_config['termination_args']&#10;    crossover_prob = float(ga_config['crossover_prob'])&#10;    mutation_prob = float(ga_config['mutation_prob'])&#10;    tournament_size = int(ga_config['tournament_size'])&#10;    pop_num = int(ga_config['pop_num'])&#10;    checkpoint_file = os\.path\.join(experiment_folder, &quot;ga_checkpoint\.pkl&quot;)&#10;    &#10;    # Extract chromosome definitions&#10;    ga_params = ga_config['ga_chromosome_def']&#10;    print(&quot;Loaded chromosome definitions: {}&quot;\.format(ga_params))&#10;    &#10;    # Run the optimization and get results&#10;    result = run_optimizer()&#10;    print(&quot;\\nOptimization Completed!\\n&quot;)&#10;    print(&quot;Result:\\n{}&quot;\.format(result))&#10;    &#10;    # Return the DataFrame directly&#10;    return result"/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="distance_type" value="l1"/>
        <parameter key="pop_num" value="5"/>
        <parameter key="termination_crit" value="genmax"/>
      </operator>
      <connect from_port="input 1" to_op="GA Optimizer" to_port="data"/>
      <connect from_op="GA Optimizer" from_port="out" to_port="result 1"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="source_input 2" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <portSpacing port="sink_result 2" spacing="0"/>
    </process>
  </operator>
  <title>GA Optimizer</title>
  <icon>magic_wand.png</icon>
  <description/>
  <synopsis/>
  <number-of-inputs>1</number-of-inputs>
  <number-of-outputs>1</number-of-outputs>
  <defines-optionals>true</defines-optionals>
  <param-ordering>true</param-ordering>
  <gets-random-seed>true</gets-random-seed>
  <custom-operator-type>standard</custom-operator-type>
  <template-parameters>
    <template-parameter>
      <operator>GA Optimizer</operator>
      <parameter>distance_type</parameter>
      <alias>distance_type</alias>
      <documentation>By default parameters are of type string.</documentation>
    </template-parameter>
    <template-parameter>
      <operator>GA Optimizer</operator>
      <parameter>pop_num</parameter>
      <alias>pop_num</alias>
      <documentation>Population Number</documentation>
    </template-parameter>
    <template-parameter>
      <operator>GA Optimizer</operator>
      <parameter>termination_crit</parameter>
      <alias>termination_crit</alias>
      <documentation>Categorical parameter.</documentation>
    </template-parameter>
  </template-parameters>
  <input-docu>
    <port>
      <type>com.rapidminer.operator.IOObject</type>
      <description>An input port</description>
    </port>
  </input-docu>
  <output-docu>
    <port>
      <type>com.rapidminer.example.ExampleSet</type>
      <description>A result port</description>
    </port>
  </output-docu>
  <tutorials>
    <tutorial>
      <title>Unknown title</title>
      <description/>
      <xml/>
    </tutorial>
  </tutorials>
</process>
