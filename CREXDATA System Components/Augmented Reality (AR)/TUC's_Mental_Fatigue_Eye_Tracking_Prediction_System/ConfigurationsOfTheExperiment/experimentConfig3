import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from math import nan
from classes.findingClosest import BufferProc
from datetime import datetime
from scipy.spatial import cKDTree
from sklearn.preprocessing import MinMaxScaler
from classes.dfTransferer import slidingWindowAlternate
import os
import matplotlib.pyplot as plt

FPS = 50
WINDOWS_BEFORE = 60
WINDOWS_AFTER = 1499
# path = "C:/Users/AlexisPC/Desktop/alexiTestMF.csv"
path = "C:/Users/AlexisPC/Desktop/INDUCING_MENTAL_FATIGUE/Alexis2/alexiTestMF.csv"
path2 = "C:/Users/AlexisPC/Desktop/INDUCING_MENTAL_FATIGUE/Alexis2/FullSlidingWindowAlexis.csv"

################################################################
mentalTestDF = pd.read_csv(path)
# Name of the column you're checking
target_columns = [
    "StartTime",
    "AXCPTtrialsLoop1.thisRepN",
    "NBackTrialsLoop1.thisRepN",
    "searchLoop1.thisRepN",
    "mentRotTrialsLoop1.thisRepN",
    "NBackTrialsLoop2.thisRepN",
    "AXCPTtrialsLoop2.thisRepN",
    "searchLoop2.thisRepN",
    "mentRotTrialsLoop2.thisRepN",
]

user_inputs = []
stop_input = False

for col in target_columns:
    if not stop_input:
        value = input(f"Enter a value for '{col}' (leave blank to stop): ").strip()
        if value == "":
            stop_input = True
            user_inputs.append(None)
        else:
            user_inputs.append(value)
    else:
        user_inputs.append(None)

# Create a DataFrame to store results
print(user_inputs)
mentalTestDF.columns = mentalTestDF.columns.str.strip()
input_df = pd.DataFrame({"column": target_columns, "user_value": user_inputs})
original_str = mentalTestDF.at[2, "date"]
start_time = datetime.strptime(original_str.strip(), "%Y-%m-%d_%Hh%M.%S.%f")
print(value)
print("\nUser inputs:")


# Create a new column in input_df to store date values
input_df["task_start_date"] = None
input_df["task_end_date"] = None

for idx, row in input_df.iterrows():
    col = row["column"]
    user_value = row["user_value"]

    if (
        pd.notna(user_value)
        and col in mentalTestDF.columns
        and "date" in mentalTestDF.columns
    ):
        series = mentalTestDF[col]
        active = series.notna() & (series.astype(str).str.strip() != "")

        if active.any():
            if col == "AXCPTtrialsLoop1.thisRepN":
                # First non-null index
                start_index = active.idxmax()
                # Find when it becomes null again after that
                following = active.loc[start_index:]
                try:
                    end_index = following[~following].index[0] - 1
                except IndexError:
                    end_index = following.index[-1]

                # Assign AXCPT trial's start and end
                input_df.at[idx, "task_start_date"] = start_time + timedelta(
                    seconds=mentalTestDF.at[start_index, "elapsed.time"]
                )
                input_df.at[idx, "task_end_date"] = start_time + timedelta(
                    seconds=mentalTestDF.at[end_index, "elapsed.time"]
                )

                match_idx = input_df.index[input_df["column"] == "StartTime"]
                if not match_idx.empty:
                    input_df.at[match_idx[0], "task_end_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[start_index, "elapsed.time"]
                    )

            elif col != "StartTime" and col != "AXCPTtrialsLoop1.thisRepN":
                # For other columns, find the last index before it turns null again
                first_block = active[active].index

                if not first_block.empty:
                    # Now check where it becomes inactive again after the first valid
                    start_index = first_block[0]
                    following = active.loc[start_index:]
                    try:
                        end_index = following[~following].index[0] - 1
                    except IndexError:
                        end_index = following.index[-1]
                    input_df.at[idx, "task_start_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[start_index, "elapsed.time"]
                    )
                    input_df.at[idx, "task_end_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[end_index, "elapsed.time"]
                    )

print(input_df)


##############################################################

eyeTrackingData = pd.read_csv(path2)
eyeTrackingData.columns = eyeTrackingData.columns.str.strip()
eyeTrackingData["last real_datetime"] = pd.to_datetime(
    eyeTrackingData["last real_datetime"], errors="coerce"
)
input_df["task_start_date"] = pd.to_datetime(
    input_df["task_start_date"], errors="coerce"
)
input_df["task_end_date"] = pd.to_datetime(input_df["task_end_date"], errors="coerce")
input_df = input_df.dropna(subset=["task_end_date"])

# Convert timestamps to datetime and then to microseconds

eyeTrackingTimeStamps = pd.to_datetime(eyeTrackingData["last real_datetime"])
eyeTrackingData["FrameWallClock"] = eyeTrackingTimeStamps.astype("int64")
frame_wall_clock_reshaped = eyeTrackingData["FrameWallClock"].values.reshape(-1, 1)
frame_wall_clock_df = pd.DataFrame(
    frame_wall_clock_reshaped, columns=["FrameWallClock"]
)
tree = cKDTree(eyeTrackingData["FrameWallClock"].values.reshape(-1, 1))
pavloviaEnd = pd.to_datetime(input_df["task_end_date"])
input_df["end_Unix"] = pavloviaEnd.astype("int64")
_, endIndex = tree.query(input_df["end_Unix"].values.reshape(-1, 1), k=1)
print("End Index:", input_df["end_Unix"].values.reshape(-1, 1))
windows = []  # list to collect DataFrames
endOfTask = []
for i in range(len(endIndex)):
    print(eyeTrackingData.index.get_loc(endIndex[i]))
    pos = eyeTrackingData.index.get_loc(endIndex[i])
    rows_before_inclusive = eyeTrackingData.iloc[pos - WINDOWS_BEFORE : pos + 1]

    try:
        user_val = float(input_df.iloc[i]["user_value"])
        normalized = ((user_val - 0) / 4) * 10
        if normalized < 3:
            normalized = 1
        elif normalized <= 8:
            normalized = 2
        else:
            normalized = 3
    except ValueError:
        print("Invalid value:", user_val)
    rows_before_inclusive["Test Name"] = input_df.iloc[i]["column"]
    if "label" not in eyeTrackingData.columns:
        eyeTrackingData["label"] = None  # or np.nan if you prefer
    eyeTrackingData.loc[pos - WINDOWS_BEFORE : pos, "label"] = normalized
    windows.append(rows_before_inclusive)
    cell = (input_df.iloc[i]["column"], eyeTrackingData.index.get_loc(endIndex[i]))
    endOfTask.append(cell)
    combined_df = pd.concat(windows, ignore_index=True)
    combined_df.reset_index(drop=True, inplace=True)
print("endOfTask:", endOfTask)

#############################################################


# minutes = eyeTrackingData.index  # x-axis = 0, 1, 2, ...

# fig, axs = plt.subplots(3, 1, figsize=(12, 8), sharex=True)

# # --- first subplot ---
# axs[0].plot(minutes, eyeTrackingData["label"], marker="o")
# axs[0].set_title("Label Over Time")
# axs[0].set_ylabel("Label")
# axs[0].grid(True)

# # ---  second subplot ---
# axs[1].plot(minutes, eyeTrackingData["mean pupil diameter"], marker="o")
# axs[1].set_title("Mean Pupil Diameter Over Time")
# axs[1].set_ylabel("Mean Pupil Diameter")
# axs[1].grid(True)

# # ---  third subplot ---
# axs[2].plot(minutes, eyeTrackingData["blink count"], marker="o")
# axs[2].set_title("Blink Count Over Time")
# axs[2].set_ylabel("Blink Count")
# axs[2].grid(True)

# # --- Custom x-ticks based on endOfTask ---
# positions = [pos for (name, pos) in endOfTask]  # 15, 30, 45
# labels = [name for (name, pos) in endOfTask]  # "alexis", "maria", "john"

# axs[2].set_xticks(positions)
# axs[2].set_xticklabels(labels, rotation=45, ha="right")

# axs[2].set_xlabel("Task Name")

# plt.tight_layout()
# plt.show()
#############################################################

# Combine your windows
# print("Windows before concatenation:", windows)

print("Combined DataFrame:", combined_df)
# Columns to plot (exclude 'last_real_datetime' and 'Self Report')
skip = {
    "last real_datetime",
    "Self Report",
    "FrameWallClock",
    "Test Name",  # <- don’t plot this one
    "label",  # <- and drop “label” if that’s also non-numeric
}
columns_to_plot = [c for c in combined_df.columns if c not in skip]

# 2) build a 0,1,2,… x-axis
seconds = np.arange(len(combined_df))

# 3) detect Test Name changes (and kill the bogus first-row NaN→value “change”)
mask = combined_df["Test Name"].ne(combined_df["Test Name"].shift())
mask.iloc[0] = False

change_points = seconds[mask]
previous_names = combined_df["Test Name"].shift()[mask].tolist()

# 4) make the subplots
fig, axs = plt.subplots(
    nrows=len(columns_to_plot),
    ncols=1,
    figsize=(14, 2.5 * len(columns_to_plot)),
    sharex=True,
)
if len(columns_to_plot) == 1:
    axs = [axs]

# plot each numeric series + vertical lines
for ax, col in zip(axs, columns_to_plot):
    ax.plot(seconds, combined_df[col], marker="o", markersize=2, linewidth=1)
    ax.set_title(col, fontsize=10)
    ax.grid(True, axis="x", linestyle="--", linewidth=0.5)
    # for x in change_points:
    #     ax.axvline(x, color="gray", linestyle="--", linewidth=0.6)

# 5) label the bottom axis only
tick_positions = change_points - 1
# drop any negative positions (in case a change was at t=0)
last_pos = seconds[-1]
last_label = combined_df["Test Name"].iloc[-1]

tick_positions = np.concatenate([tick_positions, [last_pos]])
previous_names.append(last_label)

# 5b) now set ticks/labels (including that final one)
bottom = axs[-1]
bottom.set_xticks(tick_positions)
bottom.set_xticklabels(previous_names, rotation=30, ha="right", fontsize=8)
bottom.set_xlabel("Previous Test Name", fontsize=10)
print("columns in df:", combined_df.columns)
combined_df.to_csv(
    "C:/Users/AlexisPC/Desktop/INDUCING_MENTAL_FATIGUE/Alexis2/slidingWindowAlexis2.csv",
    index=False,
)
plt.tight_layout()
plt.subplots_adjust(hspace=0.4, bottom=0.15)
plt.show()
