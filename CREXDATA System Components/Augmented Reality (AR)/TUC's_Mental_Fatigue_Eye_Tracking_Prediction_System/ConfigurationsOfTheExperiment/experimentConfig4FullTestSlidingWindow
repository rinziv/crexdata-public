import sys

sys.path.append("C:/Users/AlexisPC/Desktop/pythonEYE/classes")
import dfTransferer
import pandas as pd
import numpy as np

pd.options.mode.chained_assignment = None  # default='warn'
from datetime import datetime, timedelta
from math import nan
from datetime import datetime
from scipy.spatial import cKDTree
from sklearn.preprocessing import MinMaxScaler
import os
import matplotlib.pyplot as plt
from pathlib import Path

FPS = 50
WINDOWS_BEFORE = 60
WINDOWS_AFTER = 1499
NAME = "rosa"  # change this to the name of the subject
# path = "C:/Users/AlexisPC/Desktop/alexiTestMF.csv"
path = f"C:/Users/AlexisPC/Desktop/UPDATED_INDUCING_MENTAL_FATIGUE/{NAME}/{NAME}PavloviaMF.csv"
path2 = f"C:/Users/AlexisPC/Desktop/UPDATED_INDUCING_MENTAL_FATIGUE/{NAME}/{NAME}MetricsFromVideosCorrectConv.csv"

################################################################
mentalTestDF = pd.read_csv(path)
# Name of the column you're checking
target_columns = [
    "StartTime",
    "AXCPTtrialsLoop1.thisRepN",
    "NBackTrialsLoop1.thisRepN",
    "searchLoop1.thisRepN",
    "mentRotTrialsLoop1.thisRepN",
    "NBackTrialsLoop2.thisRepN",
    "AXCPTtrialsLoop2.thisRepN",
    "searchLoop2.thisRepN",
    "mentRotTrialsLoop2.thisRepN",
    "NBackTrialsLoop3.thisRepN",
    "searchLoop3.thisRepN",
    "mentRotTrialsLoop3.thisRepN",
    "AXCPTtrialsLoop3.thisRepN",
]

user_inputs = [
    "2024-01-15 14:30:00",  # StartTime
    "0",  # AXCPTtrialsLoop1.thisRepN
    "0",  # NBackTrialsLoop1.thisRepN
    "0",  # searchLoop1.thisRepN
    "0",  # mentRotTrialsLoop1.thisRepN
    None,  # Rest are None (stop early)
    None,
    None,
    None,
    None,
    None,
    None,
    None,
]

# Comment out the input loop
# for col in target_columns:
#     if not stop_input:
#         value = input(f"Enter a value for '{col}' (leave blank to stop): ").strip()  # ← LINE 42: Waiting for keyboard input!
#         if value == "":
#             stop_input = True
#             user_inputs.append(None)
#         else:
#             user_inputs.append(value)
#     else:
#         user_inputs.append(None)

# Create a DataFrame to store results
mentalTestDF.columns = mentalTestDF.columns.str.strip()
input_df = pd.DataFrame({"column": target_columns, "user_value": user_inputs})
original_str = mentalTestDF.at[2, "date"]
start_time = datetime.strptime(original_str.strip(), "%Y-%m-%d_%Hh%M.%S.%f")


# Create a new column in input_df to store date values
input_df["task_start_date"] = None
input_df["task_end_date"] = None

for idx, row in input_df.iterrows():
    col = row["column"]
    user_value = row["user_value"]

    if (
        pd.notna(user_value)
        and col in mentalTestDF.columns
        and "date" in mentalTestDF.columns
    ):
        series = mentalTestDF[col]
        active = series.notna() & (series.astype(str).str.strip() != "")

        if active.any():
            if col == "AXCPTtrialsLoop1.thisRepN":
                # First non-null index
                start_index = active.idxmax()
                # Find when it becomes null again after that
                following = active.loc[start_index:]
                try:
                    end_index = following[~following].index[0] - 1
                except IndexError:
                    end_index = following.index[-1]

                # Assign AXCPT trial's start and end
                input_df.at[idx, "task_start_date"] = start_time + timedelta(
                    seconds=mentalTestDF.at[start_index, "elapsed.time"]
                )
                input_df.at[idx, "task_end_date"] = start_time + timedelta(
                    seconds=mentalTestDF.at[end_index, "elapsed.time"]
                )

                match_idx = input_df.index[input_df["column"] == "StartTime"]
                if not match_idx.empty:
                    input_df.at[match_idx[0], "task_end_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[start_index, "elapsed.time"]
                    )

            elif col != "StartTime" and col != "AXCPTtrialsLoop1.thisRepN":
                # For other columns, find the last index before it turns null again
                first_block = active[active].index

                if not first_block.empty:
                    # Now check where it becomes inactive again after the first valid
                    start_index = first_block[0]
                    following = active.loc[start_index:]
                    try:
                        end_index = following[~following].index[0] - 1
                    except IndexError:
                        end_index = following.index[-1]
                    input_df.at[idx, "task_start_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[start_index, "elapsed.time"]
                    )
                    input_df.at[idx, "task_end_date"] = start_time + timedelta(
                        seconds=mentalTestDF.at[end_index, "elapsed.time"]
                    )


##############################################################
print("input_df:", input_df)
eyeTrackingData = pd.read_csv(path2)
eyeTrackingData.columns = eyeTrackingData.columns.str.strip()
eyeTrackingData["Real Date Time"] = pd.to_datetime(
    eyeTrackingData["Real Date Time"], errors="coerce"
)
input_df["task_start_date"] = pd.to_datetime(
    input_df["task_start_date"], errors="coerce"
)
input_df["task_end_date"] = pd.to_datetime(input_df["task_end_date"], errors="coerce")
input_df = input_df.dropna(subset=["task_end_date"])

# Convert timestamps to datetime and then to correct unit
eyeTrackingTimeStamps = pd.to_datetime(eyeTrackingData["Real Date Time"])

# FIX: For Katerina, use microseconds; for others, use nanoseconds
if NAME == "katerina":
    eyeTrackingData["FrameWallClock"] = eyeTrackingTimeStamps.astype("int64") // 1000
    print("Using MICROSECONDS for Katerina")
else:
    eyeTrackingData["FrameWallClock"] = eyeTrackingTimeStamps.astype("int64")
    print("Using NANOSECONDS")

frame_wall_clock_reshaped = eyeTrackingData["FrameWallClock"].values.reshape(-1, 1)
frame_wall_clock_df = pd.DataFrame(
    frame_wall_clock_reshaped, columns=["FrameWallClock"]
)
tree = cKDTree(eyeTrackingData["FrameWallClock"].values.reshape(-1, 1))
pavloviaEnd = pd.to_datetime(input_df["task_end_date"])
pavloviaStart = pd.to_datetime(input_df["task_start_date"])

# Convert Pavlovia timestamps to same unit as eye tracking data
if NAME == "katerina":
    input_df["start_Unix"] = pavloviaStart.astype("int64") // 1000
    input_df["end_Unix"] = pavloviaEnd.astype("int64") // 1000
else:
    input_df["start_Unix"] = pavloviaStart.astype("int64")
    input_df["end_Unix"] = pavloviaEnd.astype("int64")

_, startIndex = tree.query(input_df["start_Unix"].values.reshape(-1, 1), k=1)
_, endIndex = tree.query(input_df["end_Unix"].values.reshape(-1, 1), k=1)

windows = []
endOfTask = []
print("startIndex:", startIndex)
print("endIndex:", endIndex)

for i in range(len(endIndex)):
    # FIX: startIndex and endIndex are already positional integers from tree.query
    pos = endIndex[i]
    idx_start = startIndex[i]

    print(f"Task {i}: Extracting rows {idx_start} to {pos}")

    try:
        user_val = float(input_df.iloc[i]["user_value"])
        normalized = ((user_val - 0) / 4) * 10
        if normalized < 2.5:
            normalized = 1
        elif normalized < 5:
            normalized = 2
        elif normalized < 7.5:
            normalized = 3
        else:
            normalized = 4
    except ValueError:
        print("Invalid value:", user_val)
        normalized = np.nan

    # ✅ FIX: Assign selfReportTest BEFORE extracting rows
    if "selfReportTest" not in eyeTrackingData.columns:
        eyeTrackingData["selfReportTest"] = None

    eyeTrackingData.iloc[
        idx_start : pos + 1, eyeTrackingData.columns.get_loc("selfReportTest")
    ] = normalized

    # ✅ FIX: Extract rows AFTER assignment so the copy includes selfReportTest
    rows_before_inclusive = eyeTrackingData.iloc[idx_start : pos + 1].copy()
    rows_before_inclusive["Test Name"] = input_df.iloc[i]["column"]

    print(f"  Captured {len(rows_before_inclusive)} rows")

    windows.append(rows_before_inclusive)
    cell = (input_df.iloc[i]["column"], pos)
    endOfTask.append(cell)

# FIX: Move concat OUTSIDE the loop
combined_df = pd.concat(windows, ignore_index=True)
combined_df.reset_index(drop=True, inplace=True)

numeric_cols = [
    "timeStamp",
    "frameN",
    "pupilSize",
    "pupCntr_x",
    "pupCntr_y",
    "eyeProb",
    "blinkProb",
    "angDistance",
    "angVelocity",
    "angAcceleration",
]

# force conversion
combined_df[numeric_cols] = combined_df[numeric_cols].apply(
    pd.to_numeric, errors="coerce"
)
print("endOfTask:", endOfTask)

#############################################################


# skip = {
#     "Real Date Time",
#     "Self Report",
#     "FrameWallClock",
#     "Test Name",
#     "label",
# }
# columns_to_plot = [c for c in combined_df.columns if c not in skip]

# # 2) build a 0,1,2,… x-axis
# seconds = np.arange(len(combined_df))

# # 3) detect Test Name changes (and kill the bogus first-row NaN→value “change”)
# mask = combined_df["Test Name"].ne(combined_df["Test Name"].shift())
# mask.iloc[0] = False

# change_points = seconds[mask]
# previous_names = combined_df["Test Name"].shift()[mask].tolist()

# # 4) make the subplots
# fig, axs = plt.subplots(
#     nrows=len(columns_to_plot),
#     ncols=1,
#     figsize=(14, 2.5 * len(columns_to_plot)),
#     sharex=True,
# )
# if len(columns_to_plot) == 1:
#     axs = [axs]

# for ax, col in zip(axs, columns_to_plot):
#     ax.plot(seconds, combined_df[col], marker="o", markersize=2, linewidth=1)
#     ax.set_title(col, fontsize=10)
#     ax.grid(True, axis="x", linestyle="--", linewidth=0.5)


# # 5) label the bottom axis only
# tick_positions = change_points - 1
# # drop any negative positions (in case a change was at t=0)
# last_pos = seconds[-1]
# last_label = combined_df["Test Name"].iloc[-1]

# tick_positions = np.concatenate([tick_positions, [last_pos]])
# previous_names.append(last_label)

# # 5b) now set ticks/labels (including that final one)
# bottom = axs[-1]
# bottom.set_xticks(tick_positions)
# bottom.set_xticklabels(previous_names, rotation=30, ha="right", fontsize=8)
# bottom.set_xlabel("Previous Test Name", fontsize=10)
#############################################################


grouped_data = combined_df.groupby("Test Name")
print("grouped_data:", grouped_data)
print(f"Total rows in combined_df: {len(combined_df)}")

sliding_results = []
for i, group in enumerate(grouped_data):
    _, groupDF = group

    print(f"Group {i}: {groupDF['Test Name'].iloc[0]}, {len(groupDF)} rows")

    if len(groupDF) < 50:
        print(
            f"Warning: Group {i} has only {len(groupDF)} rows, skipping sliding window"
        )
        continue

    sliding = dfTransferer.slidingWindowAlternate(groupDF, 50)
    print(f"  Sliding window result: {len(sliding)} rows")

    if len(sliding) > 0:
        sliding["Test Name"] = groupDF["Test Name"].iloc[0]
        sliding["selfReportTest"] = groupDF["selfReportTest"].iloc[0]
        sliding_results.append(sliding)
    else:
        print(f"  Warning: Sliding window returned empty DataFrame")

# Check if we have results before saving
if len(sliding_results) == 0:
    print("ERROR: No sliding window results generated!")
    print(f"Combined_df has {len(combined_df)} rows")
    print(
        "Check if groups have enough data or if slidingWindowAlternate is working correctly"
    )
else:
    sliding_df = pd.concat(sliding_results, ignore_index=True)
    print(f"Final sliding_df has {len(sliding_df)} rows")

    sliding_df.to_csv(
        f"C:/Users/AlexisPC/Desktop/allCSV/{NAME}SlidingWindowResults.csv",
        index=False,
    )
    print(
        f"Successfully saved to C:/Users/AlexisPC/Desktop/allCSV/{NAME}SlidingWindowResults.csv"
    )

# plt.tight_layout()
# plt.subplots_adjust(hspace=0.4, bottom=0.15)
# plt.show()
# plt.show()
